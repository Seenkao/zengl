<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//RU">
<HTML>
  <HEAD>
    <title>ZenGL help</title>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>
    <style type="text/css">
      a         {text-decoration: none;}
      a.g       {font-family: monospace; font-size: 10pt; color: #000000;}
      a:hover.g {font-family: monospace; font-size: 10pt; color: #228822;}
      a.b       {color: #5555FF;}
      a:hover.b {color: #0000FF;}
      div.code  {font-family: monospace; font-size: 10pt; background: #A3A3A3;}
    </style>
  </HEAD>
  <BODY bgcolor='#D6D6D6' text='#000000'>
    <a name='index'>
    <div align='center'><img alt='LOGO' src='data/zengl.png'></div>
    <UL type='disc' title='Оглавление'>
      <LI><a class='b' href='#zgl_main'><b>zgl_main.pas</b></a></LI>
      <LI><a class='b' href='#zgl_screen'><b>zgl_screen.pas</b></a></LI>
      <LI><a class='b' href='#zgl_window'><b>zgl_window.pas</b></a></LI>
      <LI><a class='b' href='#zgl_opengl_simple'><b>zgl_opengl_simple.pas</b></a></LI>
      <LI><a class='b' href='#zgl_timers'><b>zgl_timers.pas</b></a></LI>
      <LI><a class='b' href='#zgl_ini'><b>zgl_ini.pas</b></a></LI>
      <LI><a class='b' href='#zgl_mouse'><b>zgl_mouse.pas</b></a></LI>
      <LI><a class='b' href='#zgl_keyboard'><b>zgl_keyboard.pas</b></a></LI>
      <LI><a class='b' href='#zgl_textures'><b>zgl_textures.pas</b></a></LI>
      <LI><a class='b' href='#zgl_render_target'><b>zgl_render_target.pas</b></a></LI>
      <LI><a class='b' href='#zgl_fx'><b>zgl_fx.pas</b></a></LI>
      <LI><a class='b' href='#zgl_render_2d'><b>zgl_render_2d.pas</b></a></LI>
      <LI><a class='b' href='#zgl_camera_2d'><b>zgl_camera_2d.pas</b></a></LI>
      <LI><a class='b' href='#zgl_primitives_2d'><b>zgl_primitives_2d.pas</b></a></LI>
      <LI><a class='b' href='#zgl_sprite_2d'><b>zgl_sprite_2d.pas</b></a></LI>
      <LI><a class='b' href='#zgl_font'><b>zgl_font.pas</b></a></LI>
      <LI><a class='b' href='#zgl_text'><b>zgl_text.pas</b></a></LI>
    </UL>

  <!--zgl_main.pas-->
  <p><hr>Справка далеко не полная, и находится в стадии разработки. По мере "устаканивания" некоторых функций библиотеки, тут будет появляться их описание.<hr>
  <a name='zgl_main'><h2 style='color: #DD0000'>zgl_main.pas</h2>
  <b>Константы:</b>
  <UL type='disc'>
  <LI>Константы используемые с функцией <a href='#zgl_Reg'>zgl_Reg</a>:</LI>
    <UL type="disc">
      <LI><b>SYS_LOAD</b> - регистрирует функцию, что будет вызвана сразу после инициализации</LI>
      <LI><b>SYS_DRAW</b> - регистрирует функцию, что будет вызываться каждую итерацию главного цикла</LI>
      <LI><b>SYS_UPDATE</b> - регистрирует функцию, что будет вызываться каждую итерацию главного цикла и возвращать разницу времени между последним вызовом(dt)</LI>
      <LI><b>SYS_EXIT</b> - регистрирует функцию, которая будет вызвана после завершения работы библиотеки и очистки всех ресурсов</LI>
      <LI><b>TEX_FORMAT_EXTENSION</b> - начинает регистрацию поддержки нового графического формата</LI>
      <LI><b>TEX_FORMAT_FILE_LOADER</b> - регистрирует функцию загрузки граф. формата из файла</LI>
      <LI><b>TEX_FORMAT_MEM_LOADER</b> - регистрирует функцию загрузки граф. формата из памяти</LI>
      <LI><b>SND_FORMAT_EXTENSION</b> - начинает регистрацию поддержки нового формата аудио-файла</LI>
      <LI><b>SND_FORMAT_FILE_LOADER</b> - регистрирует функцию загрузки аудио-файла из файла</LI>
      <LI><b>SND_FORMAT_MEM_LOADER</b> - регистрирует функцию загрузки аудио-файла из памяти</LI>
      <LI><b>SND_FORMAT_STREAM</b> - регистрирует структуру zglTSoundStream, в которой указаны формат, функции декодинга потока и пр. параметры</LI>
      <!--LI><b>WIDGET_TYPE_ID</b> - начинает регистрацию нового типа виджета</LI>
      <LI><b>WIDGET_FILL_DESC</b> - регистрирует функцию, которая будет заполнять структуру описания виджета</LI>
      <LI><b>WIDGET_ONDRAW</b> - регистрирует функцию отрисовки виджета</LI>
      <LI><b>WIDGET_ONPROC</b> - регистрирует функцию обработки виджета</LI-->
    </UL>
  <LI>Константы используемые с функцией <a href='#zgl_Get'>zgl_Get</a>:</LI>
    <UL type="disc">
      <LI><b>SYS_FPS</b> - возвращает количество кадров в секунду</LI>
      <LI><b>APP_PAUSED</b> - возвращает 1, если приложение на паузе</LI>
      <LI><b>APP_DIRECTORY</b> - возвращает PChar строку содержащую путь к директории, откуда было запущено приложение</LI>
      <LI><b>USR_HOMEDIR</b> - возвращает PChar строку содежащую путь к домашней директории пользователя</LI>
      <LI><b>LOG_FILENAME</b> - возвращает указатель на PChar строку, содержащую путь и имя log-файла. По указателю путь и имя можно изменить</LI>
      <!--LI><b>ZGL_VERSION</b> - </LI-->
      <LI><b>SCR_ADD_X</b> - возвращает смещение по X, если используется CORRECT_RESOLUTION</LI>
      <LI><b>SCR_ADD_Y</b> - возвращает смещение по Y, если используется CORRECT_RESOLUTION</LI>
      <LI><b>DESKTOP_WIDTH</b> - возвращает текущее разрешение экрана пользователя по ширине</LI>
      <LI><b>DESKTOP_HEIGHT</b> - возвращает текущее разрешение экрана пользователя по высоте</LI>
      <LI><b>RESOLUTION_LIST</b> - возвращает указатель на структуру zglTResolutionList, что содержит список поддерживаемых разрешений</LI>
      <!--LI><b>MANAGER_TIMER</b> - </LI>
      <LI><b>MANAGER_TEXTURE</b> - </LI>
      <LI><b>MANAGER_FONT</b> - </LI>
      <LI><b>MANAGER_RTARGET</b> - </LI>
      <LI><b>MANAGER_SOUND</b> - </LI>
      <LI><b>MANAGER_GUI</b> - </LI-->
    </UL>
  </UL>
  <b>Функции:</b><br>
  <UL type='disc'>
    <!--zgl_Init-->
    <LI><a name='zgl_Init'>
    <div class='code'><b>procedure</b> zgl_Init( <b>const</b> FSAA : Byte = 0; <b>const</b> StencilBits : Byte = 0 );</div>
    <div align='justify'>
    Создает окно, инициализирует OpenGL контекст и входит в главный цикл(функция app_MainLoop из zgl_application.pas).
    </div>
    Аргументы:
      <UL type='disc'>
        <LI><b>FSAA</b> - значение антиалиасинга;</LI>
        <LI><b>StencilBits</b> - количество бит для стенсил-буфера;</LI>
      </UL>
    </LI>

    <!--zgl_Exit-->
    <LI><a name='zgl_Exit'>
    <div class='code'><b>procedure</b> zgl_Exit;</div>
    <div align='justify'>
    Устанавливает состояние завершения работы. После текущей итерации главного цикла, цикл будет завершен, уничтожиться OpenGL контекст и окно, также очистится память от всех загруженных ресурсов.
    </div>
    </LI><br>

    <!--zgl_Reg-->
    <LI><a name='zgl_Reg'>
    <div class='code'><b>procedure</b> zgl_Reg( <b>const</b> What : DWORD; <b>const</b> UserData : Pointer );</div>
    <div align='justify'>
    Выполняет регистрацию системных функций и пр.<br>
    </div>
    Аргументы:
      <UL type='disc'>
        <LI><b>What</b> - что регистрировать;</LI>
        <LI><b>UserData</b> - регистрируемые данные(в зависимости от аргумента <b>What</b>, передается либо указатель на функцию, либо значение приведенное к типу Pointer);</LI>
      </UL>
    </LI><br>

    <!--zgl_Get-->
    <LI><a name='zgl_Get'>
    <div class='code'><b>function</b> zgl_Get( <b>const</b> What : DWORD ) : Ptr;</div>
    <div align='justify'>
    В зависимости от значения аргумента <b>What</b> возвращает определенные данные. В некоторых случаях возвращаемые данные являются указателем, т.е. Ptr(в зависимости от платформы объявляется как DWORD или QWORD) стоит расценивать как Pointer.<br>
    </div><br>

    <!--zgl_Enable-->
    <LI><a name='zgl_Enable'>
    <div class='code'><b>procedure</b> zgl_Enable( <b>const</b> What : DWORD );</div>
    <div align='justify'>
    Включает флаг <b>What</b>.
    </div><br>

    <!--zgl_Disable-->
    <LI><a name='zgl_Disable'>
    <div class='code'><b>procedure</b> zgl_Disable( <b>const</b> What : DWORD );</div>
    <div align='justify'>
    Выключает флаг <b>What</b>.
    </div>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>  </p>

  <!--zgl_screen.pas-->
  <p><hr>
  <a name='zgl_screen'><h2 style='color: #DD0000'>zgl_screen.pas</h2>
  <UL type='disc'>
    <!--scr_Clear-->
    <LI><a name='scr_Clear'>
    <div class='code'><b>procedure</b> scr_Clear;</div>
    <div align='justify'>
    Очистить экран.
    </div>
    </LI><br>

    <!--scr_Flush-->
    <LI><a name='scr_Flush'>
    <div class='code'><b>procedure</b> scr_Flush;</div>
    <div align='justify'>
    Немедленно вывести все содержимое BackBuffer'а на экран.
    </div>
    </LI><br>

    <!--scr_SetOptions-->
    <LI><a name='scr_SetOptions'>
    <div class='code'><b>procedure</b> scr_SetOptions( <b>const</b> Width, Height, BPP, Refresh : WORD; <b>const</b> FullScreen, VSync : Boolean );</div>
    <div align='justify'>
    Устанавливает настройки экрана, либо размеры окна.
    </div>
    Аргументы:
      <UL type='disc'>
        <LI><b>Width, Height</b> - ширина/высота окна, либо разрешение экрана в зависимости от аргумента <b>FullScreen</b>;</LI>
        <LI><b>BPP</b> - количекство бит на пиксель(рекомендуется всегда использовать 32, в Linux и MacOS значение не регулируется);</LI>
        <LI><b>Refresh</b> - частота обновления монитора(в Linux и MacOS не работает);</b></LI>
        <LI><b>FullScreen</b> - использовать ли полноэкранный режим;</LI>
        <LI><b>VSync</b> - включить ли вертикальную синхронизацию;</LI>
      </UL>
    </LI><br>

    <!--scr_CorrectResolution-->
    <LI><a name='scr_CorrectResolution'>
    <div class='code'><b>procedure</b> scr_CorrectResolution( <b>const</b> Width, Height : WORD );</div>
    </LI><br>

    <!--scr_SetVSync-->
    <LI><a name='scr_SetVSync'>
    <div class='code'><b>procedure</b> scr_SetVSync( <b>const</b> VSync : Boolean );</div>
    <div align='justify'>
    В зависимости от аргумента <b>VSync</b> включает/выключает вертикальную синхронизацию.
    </div>
    </LI><br>

    <!--scr_SetFSAA-->
    <LI><a name='scr_SetFSAA'>
    <div class='code'><b>procedure</b> scr_SetFSAA( <b>const</b> FSAA : Byte );</div>
    <div align='justify'>
    Меняет значение полноэкранного сглаживание на значение указанное аргументом <b>FSAA</b>.<br>
    <b>Внимание</b>: при вызове этой функции OpenGL контекст будет пересоздан и соответственно 'потеряются' все загруженные текстуры.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_window.pas-->
  <p><hr>
  <a name='zgl_window'><h2 style='color: #DD0000'>zgl_window.pas</h2>
  <UL type='disc'>
    <!--wnd_SetCaption-->
    <LI><a name='wnd_SetCaption'>
    <div class='code'><b>procedure</b> wnd_SetCaption( <b>const</b> NewCaption : <b>String</b> );</div>
    <div align='justify'>
    Устанавливает в качестве заголовка окна значение аргумента <b>NewCaption</b>.
    </div>
    </LI><br>

    <!--wnd_SetSize-->
    <LI><a name='wnd_SetSize'>
    <div class='code'><b>procedure</b> wnd_SetSize( <b>const</b> Width, Height : Integer );</div>
    <div align='justify'>
    Устанавливает размеры окна. Аргументы <b>Width</b> и <b>Height</b> отвечают за ширину и высоту окна.
    </div>
    </LI><br>

    <!--wnd_SetPos-->
    <LI><a name='wnd_SetPos'>
    <div class='code'><b>procedure</b> wnd_SetPos( <b>const</b> X, Y : Integer );</div>
    <div align='justify'>
    Устанавливает позицию окна. Аргументы <b>X</b> и <b>Y</b> служат координатами.
    </div>
    </LI><br>

    <!--wnd_ShowCursor-->
    <LI><a name='wnd_ShowCursor'>
    <div class='code'><b>procedure</b> wnd_ShowCursor( <b>const</b> Show : Boolean );</div>
    В зависимости от аргумента <b>Show</b> устанавливает видимость курсора при его перемещении в области окна.
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_opengl_simple.pas-->
  <p><hr>
  <a name='zgl_opengl_simple'><h2 style='color: #DD0000'>zgl_opengl_simple.pas</h2>
  <UL type='disc'>
    <!--Set2DMode-->
    <LI><a name='Set2DMode'>
    <div class='code'><b>procedure</b> Set2DMode;</div>
    <div align='justify'>
    Устанавливает ортогональную проекцию для рендеринга в 2D-режиме.
    </div>
    </LI><br>

    <!--Set3DMode-->
    <LI><a name='Set3DMode'>
    <div class='code'><b>procedure</b> Set3DMode( <b>const</b> FOVY : Single = 45 );</div>
    <div align='justify'>
    Устанавливает перспективную проекцию с углом обзора <b>FOVY</b>.
    </div>
    </LI><br>

    <!--zbuffer_SetDepth-->
    <LI><a name='zbuffer_SetDepth'>
    <div class='code'><b>procedure</b> zbuffer_SetDepth( <b>const</b> zNear, zFar : Single );</div>
    <div align='justify'>
    Устанавливает значения для ближней(<b>zNear</b>) и дальней(<b>zFar</b>) плоскостей отсечения.
    </div>
    </LI><br>

    <!--zbuffer_Clear-->
    <LI><a name='zbuffer_Clear'>
    <div class='code'><b>procedure</b> zbuffer_Clear;</div>
    <div align='justify'>
    Очищает содержимое буфера глубины.
    </div>
    </LI><br>

    <!--scissor_Begin-->
    <LI><a name='scissor_Begin'>
    <div class='code'><b>procedure</b> scissor_Begin( X, Y, Width, Height : Integer );</div>
    <div align='justify'>
    Ограничивает область рендеринга. Функция работает в 'накопительном' режиме, т.е. каждый вызов запоминается, и при сбросе текущего состояния функцией scissor_End, будет установлено предыдущее.
    </div>
    </LI><br>

    <!--scissor_End-->
    <LI><a name='scissor_End'>
    <div class='code'><b>procedure</b> scissor_End;</div>
    <div align='justify'>
    Сбрасывает ограничение области рендеринга до предыдущего состояния.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_timers.pas-->
  <p><hr>
  <a name='zgl_timers'><h2 style='color: #DD0000'>zgl_timers.pas</h2>
  <UL type='disc'>
    <!--timer_Add-->
    <LI><a name='timer_Add'>
    <div class='code'><b>function</b> timer_Add( <b>const</b> OnTimer : Pointer; <b>const</b> Interval : DWORD ) : zglPTimer;</div>
    <div align='justify'>
    Создает новый таймер и возвращает на него указатель. Каждые <b>Interval</b> миллисекунд будет выполняться функция <b>OnTimer</b>.
    </div>
    </LI><br>

    <!--timer_Del-->
    <LI><a name='timer_Del'>
    <div class='code'><b>procedure</b> timer_Del( <b>var</b> Timer : zglPTimer );</div>
    <div align='justify'>
    Удаляет созданный таймер по ссылке <b>Timer</b>.
    </div>
    </LI><br>

    <!--timer_GetTicks-->
    <LI><a name='timer_GetTicks'>
    <div class='code'><b>function</b> timer_GetTicks : Double;</div>
    <div align='justify'>
    Возвращает время в миллисекундах с момента старта приложения.
    </div>
    </LI><br>

    <!--timer_Reset-->
    <LI><a name='timer_Reset'>
    <div class='code'><b>procedure</b> timer_Reset;</div>
    <div align='justify'>
    Сбрасывает время во всех таймерах. Желательно выполнять эту функцию, если происходили какие-либо длительные задержки(напр. загрузка данных).
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_ini.pas-->
  <p><hr>
  <a name='zgl_ini'><h2 style='color: #DD0000'>zgl_ini.pas</h2>
  <UL type='disc'>
    <!--ini_LoadFromFile-->
    <LI><a name='ini_LoadFromFile'>
    <div class='code'><b>procedure</b> ini_LoadFromFile( <b>const</b> FileName : <b>AnsiString</b> );</div>
    <div align='justify'>
    Загрузить ini-файл <b>FileName</b>.
    </div>
    </LI><br>

    <!--ini_SaveToFile-->
    <LI><a name='ini_SaveToFile'>
    <div class='code'><b>procedure</b> ini_SaveToFile( <b>const</b> FileName : <b>AnsiString</b> );</div>
    <div align='justify'>
    Сохраняет все созданные/считанные данные в ini-файл с именем <b>FileName</b>.
    </div>
    </LI><br>

    <!--ini_Add-->
    <LI><a name='ini_Add'>
    <div class='code'><b>procedure</b> ini_Add( <b>const</b> Section, Key : <b>AnsiString</b> );</div>
    <div align='justify'>
    Добавляет в секцию <b>Section</b> ключ <b>Key</b>. Если секция <b>Section</b> не существует, она будет создана.
    </div>
    </LI><br>

    <!--ini_Del-->
    <LI><a name='ini_Del'>
    <div class='code'><b>procedure</b> ini_Del( <b>const</b> Section, Key : <b>AnsiString</b> );</div>
    <div align='justify'>
    Удаляет ключ <b>Key</b> из секции <b>Section</b>. Если аргумент <b>Key</b> передать пустым, удалится вся секция <b>Section</b>.
    </div>
    </LI><br>

    <!--ini_Clearl-->
    <LI><a name='ini_Clear'>
    <div class='code'><b>procedure</b> ini_Clear( <b>const</b> Section : <b>AnsiString</b> );</div>
    <div align='justify'>
    Удаляет все ключи из секции <b>Section</b>.
    </div>
    </LI><br>

    <!--ini_IsSection-->
    <LI><a name='ini_IsSection'>
    <div class='code'><b>function</b> ini_IsSection( <b>const</b> Section : <b>AnsiString</b> ) : Boolean;</div>
    <div align='justify'>
    Проверяет существует секция <b>Section</b>.
    </div>
    </LI><br>

    <!--ini_IsKey-->
    <LI><a name='ini_IsKey'>
    <div class='code'><b>function</b> ini_IsKey( <b>const</b> Section, Key : <b>AnsiString</b> ) : Boolean;</div>
    <div align='justify'>
    Проверяет существует ли в секции <b>Section</b> ключ <b>Key</b>.
    </div>
    </LI><br>

    <!--ini_ReadKeyStr-->
    <LI><a name='ini_ReadKeyStr'>
    <div class='code'><b>function</b> ini_ReadKeyStr( <b>const</b> Section, Key : <b>AnsiString</b>; <b>var</b> Result : AnsiString );</div>
    <div align='justify'>
    Считать строковое значение ключа <b>Key</b> из секции <b>Section</b> и записать результат в <b>Result</b>.
    </div>
    </LI><br>

    <!--ini_ReadKeyInt-->
    <LI><a name='ini_ReadKeyInt'>
    <div class='code'><b>function</b> ini_ReadKeyInt( <b>const</b> Section, Key : <b>AnsiString</b> ) : Integer;</div>
    <div align='justify'>
    Считать числовое значение ключа <b>Key</b> из секции <b>Section</b>.
    </div>
    </LI><br>

    <!--ini_ReadKeyBool-->
    <LI><a name='ini_ReadKeyBool'>
    <div class='code'><b>function</b> ini_ReadKeyBool( <b>const</b> Section, Key : <b>AnsiString</b> ) : Boolean;</div>
    <div align='justify'>
    Считать булевое значение ключа <b>Key</b> из секции <b>Section</b>.
    </div>
    </LI><br>

    <!--ini_WriteKeyStr-->
    <LI><a name='ini_WriteKeyStr'>
    <div class='code'><b>function</b> ini_WriteKeyStr( <b>const</b> Section, Key, Value : <b>AnsiString</b> ) : Boolean;</div>
    <div align='justify'>
    Присвоить ключу <b>Key</b> из секции <b>Section</b> строковое значение <b>Value</b>. Функция возвратит True если ключ был найден.
    </div>
    </LI><br>

    <!--ini_WriteKeyInt-->
    <LI><a name='ini_WriteKeyInt'>
    <div class='code'><b>function</b> ini_WriteKeyInt( <b>const</b> Section, Key : <b>AnsiString</b>; <b>const</b> Value : Integer ) : Boolean;</div>
    <div align='justify'>
    Присвоить ключу <b>Key</b> из секции <b>Section</b> числовое значение <b>Value</b>. Функция возвратит True если ключ был найден.
    </div>
    </LI><br>

    <!--ini_WriteKeyBool-->
    <LI><a name='ini_WriteKeyBool'>
    <div class='code'><b>function</b> ini_WriteKeyBool( <b>const</b> Section, Key : <b>AnsiString</b>; <b>const</b> Value : Boolean ) : Boolean;</div>
    <div align='justify'>
    Присвоить ключу <b>Key</b> из секции <b>Section</b> булевое значение <b>Value</b>. Функция возвратит True если ключ был найден.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_mouse.pas-->
  <p><hr>
  <a name='zgl_mouse'><h2 style='color: #DD0000'>zgl_mouse.pas</h2>
  <UL type='disc'>
    <!--mouse_X-->
    <LI><a name='mouse_X'>
    <div class='code'><b>function</b> mouse_X : Integer;</div>
    <div align='justify'>
    Возвращает координаты мышки по оси X относительно координат окна.
    </div>
    </LI><br>

    <!--mouse_Y-->
    <LI><a name='mouse_Y'>
    <div class='code'><b>function</b> mouse_Y : Integer;</div>
    <div align='justify'>
    Возвращает координаты мышки по оси Y относительно координат окна.
    </div>
    </LI><br>

    <!--mouse_DX-->
    <LI><a name='mouse_DX'>
    <div class='code'><b>function</b> mouse_DX : Integer;</div>
    <div align='justify'>
    Возвращает значение смещения курсора мыши по оси X после последнего вызова mouse_Lock.
    </div>
    </LI><br>

    <!--mouse_DY-->
    <LI><a name='mouse_DY'>
    <div class='code'><b>function</b> mouse_DY : Integer;</div>
    <div align='justify'>
    Возвращает значение смещения курсора мыши по оси Y после последнего вызова mouse_Lock
    </div>
    </LI><br>

    <!--mouse_Down-->
    <LI><a name='mouse_Down'>
    <div class='code'><b>function</b> mouse_Down( <b>const</b> Button : Byte ) : Boolean;</div>
    <div align='justify'>
    Возвращает True, если нажата кнопка Button.
    </div>
    </LI><br>

    <!--mouse_Up-->
    <LI><a name='mouse_Up'>
    <div class='code'><b>function</b> mouse_Up( <b>const</b> Button : Byte ) : Boolean;</div>
    <div align='justify'>
    Возвращает True, если была отпущена кнопка Button после последнего вызова mouse_ClearState.
    </div>
    </LI><br>

    <!--mouse_Click-->
    <LI><a name='mouse_Click'>
    <div class='code'><b>function</b> mouse_Click( <b>const</b> Button : Byte ) : Boolean;</div>
    <div align='justify'>
    Возвращает True, если была нажата кнопка Button после последнего вызова mouse_ClearState.
    </div>
    </LI><br>

    <!--mouse_Wheel-->
    <LI><a name='mouse_Wheel'>
    <div class='code'><b>function</b> mouse_Wheel( <b>const</b> Axis : Byte ) : Boolean;</div>
    <div align='justify'>
    Возвращает True, если была осуществлена прокрутка скролла по направлению <b>Axis</b> после последнего вызова mouse_ClearState.
    </div>
    </LI><br>

    <!--mouse_ClearState-->
    <LI><a name='mouse_ClearState'>
    <div class='code'><b>procedure</b> mouse_ClearState;</div>
    <div align='justify'>
    Сбросить состояния.
    </div>
    </LI><br>

    <!--mouse_Lock-->
    <LI><a name='mouse_Lock'>
    <div class='code'><b>procedure</b> mouse_Lock;</div>
    <div align='justify'>
    "Заблокировать" курсор мыши по центру окна
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_keyboard.pas-->
  <p><hr>
  <a name='zgl_keyboard'><h2 style='color: #DD0000'>zgl_keyboard.pas</h2>
  <UL type='disc'>
    <!--key_Down-->
    <LI><a name='key_Down'>
    <div class='code'><b>function</b> key_Down( <b>const</b> KeyCode : Byte ) : Boolean;</div>
    <div align='justify'>
    Возвращает True, если нажата клавиша с кодом <b>KeyCode</b>.
    </div>
    </LI><br>

    <!--key_Up-->
    <LI><a name='key_Up'>
    <div class='code'><b>function</b> key_Up( <b>const</b> KeyCode : Byte ) : Boolean;</div>
    <div align='justify'>
    Возвращает True, если была отпущена клавиша с кодом <b>KeyCode</b> после последнего вызова key_ClearState.
    </div>
    </LI><br>

    <!--key_Press-->
    <LI><a name='key_Up'>
    <div class='code'><b>function</b> key_Press( <b>const</b> KeyCode : Byte ) : Boolean;</div>
    <div align='justify'>
    Возвращает True, если была нажата клавиша с кодом <b>KeyCode</b> после последнего вызова key_ClearState.
    </div>
    </LI><br>

    <!--key_Last-->
    <LI><a name='key_Last'>
    <div class='code'><b>function</b> key_Last( <b>const</b> KeyAction : Byte ) : Byte;</div>
    <div align='justify'>
    Возвращает код клавиши, которая была нажата/отпущена в зависимости от значения аргумента <b>KeyAction</b>.
    </div>
    </LI><br>

    <!--key_BeginReadText-->
    <LI><a name='key_BeginReadText'>
    <div class='code'><b>procedure</b> key_BeginReadText( <b>const</b> Text : <b>AnsiString</b>; <b>const</b> MaxSymbols : WORD );</div>
    <div align='justify'>
    Сбрасывает уже набранный пользователем текст(присваивая ему значение аргумента <b>Text</b>), и "начинает" считывание нового текста, ограничивая количество вводимых символ до <b>MaxSymbols</b>.
    </div>
    </LI><br>

    <!--key_EndReadText-->
    <LI><a name='key_EndReadText'>
    <div class='code'><b>function</b> key_EndReadText( <b>var</b> Result : <b>AnsiString</b> );</div>
    <div align='justify'>
    В <b>Result</b> сохраняется набранная пользователем строка текста.
    </div>
    </LI><br>

    <!--key_ClearState-->
    <LI><a name='key_ClearState'>
    <div class='code'><b>procedure</b> key_ClearState;</div>
    <div align='justify'>
    Сбрасывает значения всех нажатых и т.д. клавиш. Следует вызывать сразу после обработки ввода.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_textures.pas-->
  <p><hr>
  <a name='zgl_textures'><h2 style='color: #DD0000'>zgl_textures.pas</h2>
  <b>Константы:</b><br>
  <UL type="disc">
  <LI>Константы используемые при создании текстуры:</LI>
    <UL type="disc">
      <LI><b>TEX_MIPMAP</b> - сгенерировать mip-уровни</LI>
      <LI><b>TEX_CLAMP</b> - </LI>
      <LI><b>TEX_REPEAT</b> - </LI>
      <LI><b>TEX_COMPRESS</b> - использовать сжатие</LI>
      <LI><b>TEX_CONVERT_TO_POT</b> - если размер текстуры не кратен степени два, к ней добавится черная рамка(на спрайтах она видна не будет), и размеры будут соответствовать ближайшим по кратности степени 2</LI>

      <LI><b>TEX_GRAYSCALE</b> - обесцветить текстуру</LI>
      <LI><b>TEX_INVERT</b> - инвертировать цвета</LI>

      <LI><b>TEX_FILTER_NEAREST</b> - не использовать фильтрацию</LI>
      <LI><b>TEX_FILTER_LINEAR</b> - использовать линейную фильтрацию</LI>
      <LI><b>TEX_FILTER_BILINEAR</b> - использовать билинейную фильтрацию</LI>
      <LI><b>TEX_FILTER_TRILINEAR</b> - использовать трилинейную фильтрацию</LI>
      <LI><b>TEX_FILTER_ANISOTROPY</b> - использовать анизотропную фильтрацию</LI>

      <LI><b>TEX_RGB</b> - создать текстуру без альфа-канала</LI>

      <LI><b>TEX_QUALITY_LOW</b> - уменьшить текстуру в четыри раза</LI>
      <LI><b>TEX_QUALITY_MEDIUM</b> - уменьшить текстуру в два раза</LI>
    </UL>
  </UL>
  <b>Функции:</b><br>
  <UL type='disc'>
    <!--tex_Add-->
    <LI><a name='tex_Add'>
    <div class='code'><b>function</b> tex_Add : zglPTexture;</div>
    <div align='justify'>
    Выделяет память под структуру zglTTexture в менеджере библиотеки и возвращает на нее указатель.
    </div>
    </LI><br>

    <!--tex_Del-->
    <LI><a name='tex_Del'>
    <div class='code'><b>procedure</b> tex_Del( <b>var</b> Texture : zglPTexture )</div>
    <div align='justify'>
    Очищает память от созданной текстуры <b>Texture</b>. После успешной очистки в <b>Textrue</b> заносится значение <b>nil</b>.
    </div>
    </LI><br>

    <!--tex_Create-->
    <LI><a name='tex_Create'>
    <div class='code'><b>procedure</b> tex_Create( <b>var</b> Texture : zglTTexture; <b>var</b> pData : Pointer );</div>
    <div align='justify'>
    Создает из данных <b>pData</b> текстуру, используя описание из <b>Texture</b>. Туда же сохраняет результат(в <b>ID</b> OpenGL идентификатор текстуры и пр.).
    </div>
    </LI><br>

    <!--tex_CreateZero-->
    <LI><a name='tex_CreateZero'>
    <div class='code'><b>function</b> tex_CreateZero( <b>const</b> Width, Height : WORD; <b>const</b> Color, Flags : DWORD ) : zglPTexture;</div>
    <div align='justify'>
    Создает текстуру с размерами <b>Width</b>, <b>Height</b> и заполняет её цветом <b>Color</b>. В качестве результата возвращает указатель на структуру zglTTextrue.
    </div>
    </LI><br>

    <!--tex_LoadFromFile-->
    <LI><a name='tex_LoadFromFile'>
    <div class='code'><b>function</b> tex_LoadFromFile( <b>const</b> FileName : <b>AnsiString</b>; <b>const</b> TransparentColor, Flags : DWORD ) : zglPTexture;</div>
    <div align='justify'>
    Загружает из графического файла <b>FileName</b> данные, создает текстуру с указанным цветом прозрачности <b>TransparentColor</b>($FF000000 - использовать альфа-канал из файла) и флагами <b>Flags</b>. В качестве результат возвращает указатель на структуру zglTTexture.
    </div>
    </LI><br>

    <!--tex_LoadFromMemory-->
    <LI><a name='tex_LoadFromMemory'>
    <div class='code'><b>function</b> tex_LoadFromMemory( <b>const</b> Memory : zglTMemory; <b>const</b> Extension : <b>AnsiString</b>; <b>const</b> TransparentColor, Flags : DWORD ) : zglPTexture;</div>
    <div align='justify'>
    Загружает из памяти <b>Memory</b>(файл целиком загруженный в память) данные, создает текстуру с указанным цветом прозрачности <b>TransparentColor</b>($FF000000 - использовать альфа-канал из файла) и флагами <b>Flags</b>. В качестве результат возвращает указатель на структуру zglTTexture. <b>Extension</b> указывает на формат файла в памяти.
    </div>
    </LI><br>

    <!--tex_SetFrameSize-->
    <LI><a name='tex_SetFrameSize'>
    <div class='code'><b>procedure</b> tex_SetFrameSize( <b>const</b> Texture : zglPTexture; FrameWidth, FrameHeight : WORD );</div>
    <div align='justify'>
    Устанавливает количество кадров в текстуре <b>Texture</b> используя ширину(<b>FrameWidth</b>) и высоту(<b>FrameHeight</b>) кадра.
    </div>
    </LI><br>

    <!--tex_SetMask-->
    <LI><a name='tex_SetMask'>
    <div class='code'><b>function</b> tex_SetMask( <b>var</b> Texture : zglPTexture; <b>const</b> Mask : zglPTexture ) : zglPTexture;</div>
    <div align='justify'>
    Применяет к текстуре <b>Texture</b> маску используя <b>Mask</b>. Размеры текстур должны быть одинаковы.
    </div>
    </LI><br>

    <!--tex_Filter-->
    <LI><a name='tex_Filter'>
    <div class='code'><b>procedure</b> tex_Filter( <b>const</b> Texture : zglPTexture; <b>const</b> Flags : DWORD );</div>
    <div align='justify'>
    </div>
    </LI><br>

    <!--tex_SetAnisotropy-->
    <LI><a name='tex_SetAnisotropy'>
    <div class='code'><b>procedure</b> tex_SetAnisotropy( <b>const</b> Level : Byte );</div>
    <div align='justify'>
    Устанавливает уровень анизотропной фильтрации для текстур.
    </div>
    </LI><br>

    <!--tex_GetData-->
    <LI><a name='tex_GetData'>
    <div class='code'><b>procedure</b> tex_GetData( <b>const</b> Texture : zglPTexture; <b>var</b> pData : Pointer; <b>var</b> pSize : Integer );</div>
    <div align='justify'>
    Извлекает из текстуры <b>Texture</b> raw-данные, и сохраняет указатель на них в <b>pData</b>. В <b>pSize</b> сохраняет размер пиксела(3 для RGB, 4 для RGBA).
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_render_target.pas-->
  <p><hr>
  <a name='zgl_render_target'><h2 style='color: #DD0000'>zgl_render_target.pas</h2>
  <b>Константы:</b><br>
  <UL type="disc">
  <LI>Константы типов RenderTargets:</LI>
    <UL type="disc">
      <LI><b>RT_TYPE_SIMPLE</b> - обычный, использует функцию glCopyTexSubImage2D</LI>
      <LI><b>RT_TYPE_FBO</b> - использует FBO</LI>
      <LI><b>RT_TYPE_PBUFFER</b> - использует PBuffer(только для Windows)</LI>
    </UL>
  <LI>Константы режимов работы RenderTargets:</LI>
    <UL type="disc">
      <LI><b>RT_FULL_SCREEN</b> - копирует весь экран</LI>
      <LI><b>RT_CLEAR_SCREEN</b> - очищает содержимое перед рендерингом нового</LI>
    </UL>
  </UL>
  <b>Функции:</b><br>
  <UL type='disc'>
    <!--rtarget_Add-->
    <LI><a name='rtarget_Add'>
    <div class='code'><b>function</b>  rtarget_Add( rtType : Byte; <b>const</b> Surface : zglPTexture; <b>const</b> Flags : Byte ) : zglPRenderTarget;</div>
    <div align='justify'>
    Создает RenderTarget типа <b>rType</b> и закрепляет за ним текстуру <b>Surface</b>.
    </div>
    </LI><br>

    <!--rtarget_Del-->
    <LI><a name='rtarget_Del'>
    <div class='code'><b>procedure</b> rtarget_Del( <b>var</b> Target : zglPRenderTarget );</div>
    <div align='justify'>
    Очищает память от созданного RenderTarget'а <b>Target</b>. После успешной очистки в <b>Target</b> заносится значение <b>nil</b>. Принадлежащая RenderTarget'у текстура <b>Surface</b> остается в памяти.
    </div>
    </LI><br>

    <!--rtarget_Set-->
    <LI><a name='rtarget_Set'>
    <div class='code'><b>procedure</b> rtarget_Set( <b>const</b> Target : zglPRenderTarget );</div>
    <div align='justify'>
    Устанавливает в качестве текущего RenderTarget'а <b>Target</b>. Если передать <b>nil</b> - рендер переходит в обычный режим.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_fx.pas-->
  <p><hr>
  <a name='zgl_fx'><h2 style='color: #DD0000'>zgl_fx.pas</h2>
  <b>Константы:</b><br>
  <UL type="disc">
  <LI>Константы для установки режима блендинга(<a href='#fx_SetBlendMode'>fx_SetBlendMode</a>):</LI>
    <UL type="disc">
      <LI><b>FX_BLEND_NORMAL</b> - обычный режим</LI>
      <LI><b>FX_BLEND_ADD</b> - аддитивный режим</LI>
      <LI><b>FX_BLEND_MULT</b> - </LI>
      <LI><b>FX_BLEND_BLACK</b> - чем темнее участок изображения тем он прозрачнее</LI>
      <LI><b>FX_BLEND_WHITE</b> - чем светлее участок изображения тем он прозрачнее</LI>
      <LI><b>FX_BLEND_MASK</b> - </LI>
    </UL>
  <LI>Константы для вывода спрайтов(<a href='#ssprite2d_Draw'>ssprite2d_Draw</a>, <a href='#asprite2d_Draw'>asprite2d_Draw</a> и <a href='#csprite2d_Draw'>csprite2d_Draw</a>):</LI>
    <UL type="disc">
      <LI><b>FX2D_FLIPX</b> - отразить текстуру по горизонтали</LI>
      <LI><b>FX2D_FLIPY</b> - отразить текстуру по вертикали</LI>
      <LI><b>FX2D_COLORMIX</b> - использовать смешивание цвета(<a href='#fx2d_SetColorMix'>fx2d_SetColorMix</a>)</LI>
      <LI><b>FX2D_COLORSET</b> - использовать "заливку" цветом(<a href='#fx2d_SetColorMix'>fx2d_SetColorMix</a>). От FX2D_COLORMIX отличается тем, что цвет текстуры будет полностью заменен указанным цветом, а не смешиваться</LI>
      <LI><b>FX2D_VCA</b> - использовать для вершин спрайта установленные значения цвета и альфы(<a href='#fx2d_SetVCA'>fx2d_SetVCA</a>). Действует также с <a href='#pr2d_Rect'>pr2d_Rect</a> и <a href='#pr2d_Line'>pr2d_Line</a></LI>
      <LI><b>FX2D_VCHANGE</b> - добавить к координатам вершин смещения установленные функцией <a href='#fx2d_SetVertexes'>fx2d_SetVertexes</a>. Действует также с <a href='#pr2d_Rect'>pr2d_Rect</a> и <a href='#pr2d_Line'>pr2d_Line</a></LI>
      <LI><b>FX2D_SCALE</b> - использовать масштабирование по горизонтали и вертикали, установленное функцией <a href='#fx2d_SetScale'>fx2d_SetScale</a></LI>
      <LI><b>FX_BLEND</b> - использовать блендинг</LI>
    </UL>
  </UL>
  <b>Функции:</b><br>
  <UL type='disc'>
    <!--fx_SetBlendMode-->
    <LI><a name='fx_SetBlendMode'>
    <div class='code'><b>procedure</b> fx_SetBlendMode( <b>const</b> Mode : Byte );</div>
    <div align='justify'>
    Устанавливает режим блендинга <b>Mode</b>. Возможные константы перечислены выше.

    </div>
    </LI><br>

    <!--fx2d_SetColorMix-->
    <LI><a name='fx2d_SetColorMix'>
    <div class='code'><b>procedure</b> fx2d_SetColorMix( <b>const</b> Color : DWORD );</div>
    <div align='justify'>
    Устанавливает цвет <b>Color</b> для смешивания. Используется с флагом FX2D_COLORMIX.
    </div>
    </LI><br>

    <!--fx2d_SetVCA-->
    <LI><a name='fx2d_SetVCA'>
    <div class='code'><b>procedure</b> fx2d_SetVCA( <b>const</b> c1, c2, c3, c4 : DWORD; <b>const</b> a1, a2, a3, a4 : Byte );</div>
    <div align='justify'>
    Устанавливает цвет и альфу для каждой вершины спрайта, прямоугольника или линии. <b>c1</b>..<b>c4</b> отвечают за цвет, <b>a1</b>..<b>a4</b> за значение альфы.
    </div>
    </LI><br>

    <!--fx2d_SetVertexes-->
    <LI><a name='fx2d_SetVertexes'>
    <div class='code'><b>procedure</b> fx2d_SetVertexes( <b>const</b> x1, y1, x2, y2, x3, y3, x4, y4 : Single );</div>
    <div align='justify'>
    Устанавливает смещения вершин. Смещения <b>x1</b>:<b>y1</b>-<b>x4</b>:<b>y4</b> действуют на вершины по часовой стрелке, начиная с верхней левой. Используется с флагом FX2D_VCHANGE.
    </div>
    </LI><br>

    <!--fx2d_SetScale-->
    <LI><a name='fx2d_SetScale'>
    <div class='code'><b>procedure</b> fx2d_SetScale( <b>const</b> scaleX, scaleY : Single );</div>
    <div align='justify'>
    Устанавливает коэфициенты масштабирования. Используется с флагом FX2D_SCALE.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_render_2d.pas-->
  <p><hr>
  <a name='zgl_render_2d'><h2 style='color: #DD0000'>zgl_render_2d.pas</h2>
  <UL type='disc'>
    <!--batch2d_Begin-->
    <LI><a name='batch2d_Begin'>
    <div class='code'><b>procedure</b> batch2d_Begin;</div>
    <div align='justify'>
    Начать отслеживать, и оптимизировать по количеству DIP'ов, вывод спрайтов с одинаковой текстурой или одинаковых по типу примитивов.
    </div>
    </LI><br>

    <!--batch2d_End-->
    <LI><a name='batch2d_Begin'>
    <div class='code'><b>procedure</b> batch2d_End;</div>
    <div align='justify'>
    Переключиться в обычный режим вывода спрайтов/примитивов без оптимизации по количеству DIP'ов
    </div>
    </LI><br>

    <!--batch2d_Flush-->
    <LI><a name='batch2d_Begin'>
    <div class='code'><b>procedure</b> batch2d_Flush;</div>
    <div align='justify'>
    Вывести на экран последнюю группу спрайтов/примитивов(по сути вызов glEnd). Следует обязательно вызывать в случаи выполнения каких-либо своих операций.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_camera_2d.pas-->
  <p><hr>
  <a name='zgl_camera_2d'><h2 style='color: #DD0000'>zgl_camera_2d.pas</h2>
  <UL type='disc'>
    <!--cam2d_Set-->
    <LI><a name='cam2d_Set'>
    <div class='code'><b>procedure</b> cam2d_Set( <b>const</b> Camera : zglPCamera2D );</div>
    <div align='justify'>
    Устанавливает текущую камеру используя указатель <b>Camera</b>.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_primitives_2d.pas-->
  <p><hr>
  <a name='zgl_primitives_2d'><h2 style='color: #DD0000'>zgl_primitives_2d.pas</h2>
  <b>Константы:</b><br>
    <UL type="disc">
      <LI><b>PR2D_FILL</b> - использовать вывод примитивов с заливкой</LI>
      <LI><b>PR2D_SMOOTH</b> - использовать сглаживание</LI>
    </UL>
  <b>Функции:</b><br>
  <UL type='disc'>
    <!--pr2d_Pixel-->
    <LI><a name='pr2d_Pixel'>
    <div class='code'><b>procedure</b> pr2d_Pixel( <b>const</b> X, Y : Single; <b>const</b> Color : DWORD; <b>const</b> Alpha : Byte = 255 );</div>
    <div align='justify'>
    Рисует точку в координатах <b>X</b>, <b>Y</b> с цветом <b>Color</b> и значением альфы <b>Alpha</b>.
    </div>
    </LI><br>

    <!--pr2d_Line-->
    <LI><a name='pr2d_Line'>
    <div class='code'><b>procedure</b> pr2d_Line( <b>const</b> X1, Y1, X2, Y2 : Single; <b>const</b> Color : DWORD; <b>const</b> Alpha : Byte = 255; <b>const</b> FX : DWORD = 0 );</div>
    <div align='justify'>
    Рисует линию из точки <b>X1</b>, <b>Y1</b> в точку <b>X2</b>, <b>Y2</b> с цветом <b>Color</b> и значением альфы <b>Alpha</b>.
    </div>
    </LI><br>

    <!--pr2d_Rect-->
    <LI><a name='pr2d_Rect'>
    <div class='code'><b>procedure</b> pr2d_Rect( <b>const</b> X, Y, W, H : Single; <b>const</b> Color : DWORD; <b>const</b> Alpha : Byte = 255; <b>const</b> FX : DWORD = 0 );</div>
    <div align='justify'>
    Рисует прямоугольник размером <b>W</b>(ширина), <b>H</b>(высота) в координатах <b>X</b>, <b>Y</b> с цветом <b>Color</b> и значением альфы <b>Alpha</b>.
    </div>
    </LI><br>

    <!--pr2d_Circle-->
    <LI><a name='pr2d_Circle'>
    <div class='code'><b>procedure</b> pr2d_Circle( <b>const</b> X, Y, Radius : Single; <b>const</b> Color : DWORD; <b>const</b> Alpha : Byte = 255; <b>const</b> Quality : WORD = 32; <b>const</b> FX : DWORD = 0 );</div>
    <div align='justify'>
    Рисует окружность с центром в координатах <b>X</b>, <b>Y</b>, радиусом <b>Radius</b>, цветом <b>Color</b> и значением альфы <b>Alpha</b>.
    </div>
    </LI><br>

    <!--pr2d_Ellipse-->
    <LI><a name='pr2d_Ellipse'>
    <div class='code'><b>procedure</b> pr2d_Ellipse( <b>const</b> X, Y, xRadius, yRadius : Single; <b>const</b> Color : DWORD; <b>const</b> Alpha : Byte = 255; <b>const</b> Quality : WORD = 32; <b>const</b> FX : DWORD = 0 );</div>
    <div align='justify'>
    Рисует эллипс с центром в координатах <b>X</b>, <b>Y</b>, радиусами <b>xRadius</b> и <b>yRadius</b>, цветом <b>Color</b> и значением альфы <b>Alpha</b>.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_sprite_2d.pas-->
  <p><hr>
  <a name='zgl_sprite_2d'><h2 style='color: #DD0000'>zgl_sprite_2d.pas</h2>
  <UL type='disc'>
    <!--ssprite2d_Draw-->
    <LI><a name='ssprite2d_Draw'>
    <div class='code'><b>procedure</b> ssprite2d_Draw( <b>const</b> Texture : zglPTexture; X, Y, W, H, Angle : Single; <b>const</b> Alpha : Byte = 255; <b>const</b> FX : DWORD = FX_BLEND );</div>
    <div align='justify'>
    Рисует спрайт используя текстуру <b>Texture</b> в координатах <b>X</b>, <b>Y</b>, размерами <b>W</b>(ширина) и <b>H</b>(высота), градусом поворота <b>Angle</b> и альфой <b>Alpha</b>.
    </div>
    </LI><br>

    <!--asprite2d_Draw-->
    <LI><a name='asprite2d_Draw'>
    <div class='code'><b>procedure</b> asprite2d_Draw( <b>const</b> Texture : zglPTexture; X, Y, W, H, Angle : Single; Frame : WORD; <b>const</b> Alpha : Byte = 255; <b>const</b> FX : DWORD = FX_BLEND );</div>
    <div align='justify'>
    Рисует спрайт используя текстуру <b>Texture</b> в координатах <b>X</b>, <b>Y</b>, размерами <b>W</b>(ширина) и <b>H</b>(высота), градусом поворота <b>Angle</b> и альфой <b>Alpha</b>. Из текстуры выбирается кадр <b>Frame</b>. Размер одного кадра устанавливается функцией <a href='#tex_SetFrameSize'>tex_SetFramesSize</a>.
    </div>
    </LI><br>

    <!--csprite2d_Draw-->
    <LI><a name='csprite2d_Draw'>
    <div class='code'><b>procedure</b> csprite2d_Draw( <b>const</b> Texture : zglPTexture; X, Y, W, H, Angle : Single; <b>const</b> CutRect : zglTRect; <b>const</b> Alpha : Byte = 255; <b>const</b> FX : DWORD = FX_BLEND );</div>
    <div align='justify'>
    Рисует спрайт используя текстуру <b>Texture</b> в координатах <b>X</b>, <b>Y</b>, размерами <b>W</b>(ширина) и <b>H</b>(высота), градусом поворота <b>Angle</b> и альфой <b>Alpha</b>. <b>CutRect</b> указывает какую часть текстуры использовать.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_font.pas-->
  <p><hr>
  <a name='zgl_font'><h2 style='color: #DD0000'>zgl_font.pas</h2>
  <UL type='disc'>
    <!--font_Add-->
    <LI><a name='font_Add'>
    <div class='code'><b>function</b> font_Add : zglPFont;</div>
    <div align='justify'>
    Выделяет память под структуру zglTFont в менеджере библиотеки и возвращает на нее указатель.
    </div>
    </LI><br>

    <!--font_Del-->
    <LI><a name='font_Del'>
    <div class='code'><b>procedure</b> font_Del( <b>var</b> Font : zglPFont );</div>
    <div align='justify'>
    Очищает память от созданного шрифта <b>Font</b>. После успешной очистки в <b>Font</b> заносится значение <b>nil</b>.
    </div>
    </LI><br>

    <!--font_LoadFromFile-->
    <LI><a name='font_LoadFromFile'>
    <div class='code'><b>function</b> font_LoadFromFile( <b>const</b> FileName : <b>AnsiString</b> ) : zglPFont;</div>
    <div align='justify'>
    Загружает из файла <b>FileName</b> данные о шрифте, создает его и возвращает указатель.
    </div>
    </LI><br>

    <!--font_LoadFromMemory-->
    <LI><a name='font_LoadFromMemory'>
    <div class='code'><b>function</b> font_LoadFromMemory( <b>const</b> Memory : zglTMemory ) : zglPFont;</div>
    <div align='justify'>
    Загружает из памяти <b>Memory</b>(файл целиком загруженный в память) данные о шрифте, создает его и возвращает указатель.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  <!--zgl_text.pas-->
  <p><hr>
  <a name='zgl_text'><h2 style='color: #DD0000'>zgl_text.pas</h2>
  <UL type='disc'>
    <!--text_Draw-->
    <LI><a name='text_Draw'>
    <div class='code'><b>procedure</b> text_Draw( <b>const</b> Font : zglPFont; X, Y : Single; <b>const</b> Text : <b>AnsiString</b>; <b>const</b> Flags : DWORD = 0 );</div>
    <div align='justify'>
    </div>
    </LI><br>

    <!--text_DrawEx-->
    <LI><a name='text_DrawEx'>
    <div class='code'><b>procedure</b> text_DrawEx( <b>const</b> Font : zglPFont; X, Y, Scale, Step : Single; <b>const</b> Text : <b>AnsiString</b>; <b>const</b> Alpha : Byte = 255; <b>const</b> Color : DWORD = $FFFFFF; <b>const</b> Flags : DWORD = 0 );</div>
    <div align='justify'>
    </div>
    </LI><br>

    <!--text_DrawInRect-->
    <LI><a name='text_DrawInRect'>
    <div class='code'><b>procedure</b> text_DrawInRect( <b>const</b> Font : zglPFont; <b>const</b> Rect : zglTRect; <b>const</b> Text : <b>AnsiString</b>; <b>const</b> Flags : DWORD = 0 );</div>
    <div align='justify'>
    </div>
    </LI><br>

    <!--text_DrawInRectEx-->
    <LI><a name='text_DrawInRectEx'>
    <div class='code'><b>procedure</b> text_DrawInRectEx( <b>const</b> Font : zglPFont; <b>const</b> Rect : zglTRect; <b>const</b> Scale, Step : Single; <b>const</b> Text : <b>AnsiString</b>; <b>const</b> Alpha : Byte = 0; <b>const</b> Color : DWORD = $FFFFFF; <b>const</b> Flags : DWORD = 0 );</div>
    <div align='justify'>
    </div>
    </LI><br>

    <!--text_GetWidth-->
    <LI><a name='text_GetWidth'>
    <div class='code'><b>function</b> text_GetWidth( <b>const</b> Font : zglPFont; <b>const</b> Text : <b>AnsiString</b>; <b>const</b> Step : Single = 0.0 ) : Single;</div>
    <div align='justify'>
    Возвращает ширину в пикселах для текста <b>Text</b>, используя данные о шрифте <b>Font</b> и размер отступа между символами <b>Step</b>. Если в тексте содержатся символы переноса строки, то возвращается ширина наиболее длинной строки.
    </div>
    </LI>
  </UL>
  <div align='left'><a class='b' href='#index'>оглавление</a></div>
  </p>

  </BODY>
</HTML>
